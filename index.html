<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 大逃殺射擊遊戲</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #000;
            color: #fff;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 讓滑鼠事件可以穿透到遊戲畫面 */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        #stats {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        .bottom-ui {
            margin-bottom: 20px;
            font-size: 20px;
            text-shadow: 2px 2px 4px #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #interaction-prompt, #item-status {
            background-color: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 10px;
        }
        #storm-warning {
            color: #ff4500;
            font-size: 28px;
            font-weight: bold;
            display: none; /* 預設隱藏 */
            text-shadow: 2px 2px 6px #000;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #game-over-screen, #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: auto; /* 讓這個畫面的按鈕可以被點擊 */
        }
        #damage-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .damage-indicator {
            position: absolute;
            color: red;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            user-select: none;
            transition: opacity 0.5s, transform 0.5s;
        }
        #health-bar-container {
            width: 250px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            padding: 2px;
            box-sizing: border-box;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #4caf50; /* Green */
            border-radius: 6px;
            transition: width 0.2s ease-out, background-color 0.5s;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        p {
            font-size: 20px;
            margin: 5px 0;
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #ff4500;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #ff6347;
        }
        button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="stats">
            <div id="opponents-left">對手: 10</div>
            <div id="storm-timer">風暴: 60s</div>
            <div id="health">生命值: 100</div>
        </div>
        <div id="storm-warning">警告：您在風暴中！</div>
        <div id="crosshair" style="display: none;"></div>
         <div class="bottom-ui">
            <div id="item-status" style="display: none;"></div>
            <div id="interaction-prompt" style="display: none;"></div>
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
        </div>
    </div>
    
    <div id="damage-container"></div>

    <div id="start-screen">
        <h1>3D 大逃殺</h1>
        <p>成為最後的存活者！</p>
        <p>WASD: 移動 | 空白鍵: 跳躍</p>
        <p>滑鼠: 瞄準/射擊 | 滑鼠右鍵: 瞄準</p>
        <p>E: 互動 (騎車/撿拾)</p>
        <p>注意不斷縮小的風暴圈！</p>
        <button id="start-button">開始遊戲</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="end-title">遊戲結束</h1>
        <p id="end-message">您已被擊敗</p>
        <button id="restart-button">重新開始</button>
    </div>

    <canvas id="game-canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- 核心變數 ---
        let scene, camera, renderer, player, gun, muzzleFlash, stormMesh;
        let playerBullets = [], opponentBullets = [], opponents = [], items = [], motorcycle;
        let damageIndicators = [];
        let health = 100;
        let gameIsOver = true;
        
        // --- 遊戲機制 ---
        const INITIAL_OPPONENTS = 10;
        let opponentsLeft = INITIAL_OPPONENTS;

        // --- 風暴圈變數 ---
        let stormState = "WAITING", stormWaitTime = 60, stormShrinkTime = 90, stormTimer = stormWaitTime;
        let stormCurrentRadius = 140, stormTargetRadius = 100;
        const STORM_DAMAGE = 0.2, stormCenter = new THREE.Vector2(0, 0);

        // --- 玩家控制 ---
        let controlsEnabled = false, keys = {}, playerVelocity = new THREE.Vector3();
        const playerSpeed = 15, playerHeight = 2.0;
        const gravity = -30;
        const jumpHeight = 10;
        let isAiming = false, playerHasScope = false, playerState = 'WALKING'; // WALKING or DRIVING
        let playerWeapon = 'pistol'; // pistol or sniper
        let shootCooldown = 0;

        // --- 載具控制 ---
        let vehicleSpeed = 0;
        const motorcycleMaxSpeed = 60, motorcycleAcceleration = 30, motorcycleBrakePower = 60, motorcycleFriction = 10, motorcycleTurnSpeed = 2.5;

        // --- 槍枝動畫 ---
        let recoilAmount = 0;
        const recoilSpeed = 0.5, recoilReturnSpeed = 0.9, defaultFov = 75;
        const defaultGunPosition = new THREE.Vector3(0.5, -0.4, -1.2);
        const aimGunPosition = new THREE.Vector3(0, -0.3, -1.0);

        // --- UI 元素 ---
        const opponentsLeftElement = document.getElementById('opponents-left'), healthElement = document.getElementById('health');
        const stormTimerElement = document.getElementById('storm-timer'), stormWarningElement = document.getElementById('storm-warning');
        const crosshairElement = document.getElementById('crosshair'), startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen'), endTitleElement = document.getElementById('end-title');
        const endMessageElement = document.getElementById('end-message'), startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button'), interactionPrompt = document.getElementById('interaction-prompt');
        const itemStatusElement = document.getElementById('item-status'), damageContainer = document.getElementById('damage-container');
        const healthBar = document.getElementById('health-bar');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 250);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(50, 80, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(300, 300);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x556B2F, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            for (let i = 0; i < 20; i++) createHouse(new THREE.Vector3((Math.random() - 0.5) * 280, 0, (Math.random() - 0.5) * 280));
            
            player = new THREE.Mesh(
                new THREE.BoxGeometry(1, playerHeight, 1),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 })
            );
            player.isPlayer = true; // 標記為玩家物件
            player.position.y = playerHeight / 2;
            scene.add(player);
            player.add(camera);
            camera.position.y = playerHeight * 0.8; 

            createGun();
            createStorm();
            createMotorcycle();
            spawnItems();
            setupControls();

            window.addEventListener('resize', onWindowResize);
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
        }

        function createHouse(position) {
            const house = new THREE.Group();
            const wallMat = new THREE.MeshPhongMaterial({color: 0xA89988});
            const roofMat = new THREE.MeshPhongMaterial({color: 0x8B4513});
            const wallHeight = 5, wallWidth = 8, wallDepth = 0.5;

            const backWall = new THREE.Mesh(new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth), wallMat);
            backWall.position.set(0, wallHeight/2, -wallWidth/2);
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallDepth, wallHeight, wallWidth), wallMat);
            leftWall.position.set(-wallWidth/2, wallHeight/2, 0);
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallDepth, wallHeight, wallWidth), wallMat);
            rightWall.position.set(wallWidth/2, wallHeight/2, 0);
            const roof = new THREE.Mesh(new THREE.BoxGeometry(wallWidth, wallDepth, wallWidth), roofMat);
            roof.position.set(0, wallHeight, 0);
            house.add(backWall, leftWall, rightWall, roof); 
            house.children.forEach(c => c.castShadow = c.receiveShadow = true);
            house.position.copy(position);
            house.rotation.y = Math.random() * Math.PI * 2;
            scene.add(house);
        }

        function createGun() {
            gun = new THREE.Group();
            gun.name = "gun";
            camera.add(gun);
            updateGunModel(); // Initial pistol model

            const muzzlePoint = new THREE.Object3D();
            muzzlePoint.position.set(0, 0.1, -1.0);
            gun.add(muzzlePoint);
            gun.muzzlePoint = muzzlePoint;
            
            const flashGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
            muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
            muzzleFlash.position.copy(muzzlePoint.position);
            muzzleFlash.visible = false;
            gun.add(muzzleFlash);
            gun.position.copy(defaultGunPosition);
        }
        
        function updateGunModel() {
            // Clear existing model
            while(gun.children.find(c => c.name === "gun_part")) {
                gun.remove(gun.children.find(c => c.name === "gun_part"));
            }
            const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

            if (playerWeapon === 'sniper') {
                 // Sniper model
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 2.0), gunMaterial);
                body.name = "gun_part";
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5, 16), gunMaterial);
                scope.name = "gun_part";
                scope.rotation.z = Math.PI / 2;
                scope.position.y = 0.2;
                gun.add(body, scope);
            } else { // Pistol
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), gunMaterial);
                body.name = "gun_part";
                const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), gunMaterial);
                barrel.name = "gun_part";
                barrel.position.set(0, 0.1, -0.7);
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), gunMaterial);
                grip.name = "gun_part";
                grip.position.set(0, -0.3, 0.2);
                grip.rotation.x = 0.2;
                gun.add(body, barrel, grip);
            }
        }

        function createStorm() {
            const stormGeometry = new THREE.CylinderGeometry(1, 1, 200, 128, 1, true);
            const stormMaterial = new THREE.MeshBasicMaterial({ color: 0x00aaff, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
            stormMesh = new THREE.Mesh(stormGeometry, stormMaterial);
            stormMesh.position.y = 100;
            scene.add(stormMesh);
        }

        function createMotorcycle() {
            motorcycle = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 3), mat);
            frame.position.y = 0.8;
            const handlebars = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.2), mat);
            handlebars.position.set(0, 1.3, -1.2);
            motorcycle.add(frame, handlebars);

            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32);
            const wheelF = new THREE.Mesh(wheelGeo, mat);
            wheelF.position.set(0, 0.5, -1.5);
            const wheelB = new THREE.Mesh(wheelGeo, mat);
            wheelB.position.set(0, 0.5, 1.5);
            wheelF.rotation.x = wheelB.rotation.x = Math.PI / 2;
            motorcycle.add(wheelF, wheelB);
            motorcycle.wheels = [wheelF, wheelB];

            motorcycle.children.forEach(c => c.castShadow = true);
            motorcycle.position.set(5, 0, 5);
            scene.add(motorcycle);
        }

        function spawnItems() {
            // Scope
            const scopeGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 16);
            const scopeMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const scopeItem = new THREE.Mesh(scopeGeo, scopeMat);
            scopeItem.castShadow = true;
            scopeItem.position.set((Math.random() - 0.5) * 50, 0.2, (Math.random() - 0.5) * 50);
            scopeItem.itemType = 'scope';
            items.push(scopeItem);
            scene.add(scopeItem);

            // Sniper Rifle
            const sniperGeo = new THREE.BoxGeometry(0.3, 0.3, 2.5);
            const sniperMat = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const sniperItem = new THREE.Mesh(sniperGeo, sniperMat);
            sniperItem.castShadow = true;
            sniperItem.position.set((Math.random() - 0.5) * 100, 0.15, (Math.random() - 0.5) * 100);
            sniperItem.itemType = 'sniper';
            items.push(sniperItem);
            scene.add(sniperItem);
        }

        function setupControls() {
            document.addEventListener('click', () => { if (!gameIsOver) document.body.requestPointerLock(); });
            document.addEventListener('pointerlockchange', () => controlsEnabled = document.pointerLockElement === document.body);
            document.addEventListener('mousemove', (e) => {
                if (!controlsEnabled || playerState === 'DRIVING') return;
                player.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'KeyE' && controlsEnabled) handleInteraction();
            });
            document.addEventListener('mousedown', (e) => { if (controlsEnabled) { if (e.button === 0 && playerState === 'WALKING') shoot(); if (e.button === 2) isAiming = true; } });
            document.addEventListener('mouseup', (e) => { if (controlsEnabled && e.button === 2) isAiming = false; });
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function startGame() {
            health = 100; opponentsLeft = INITIAL_OPPONENTS; gameIsOver = false; playerState = 'WALKING'; 
            playerHasScope = false; playerWeapon = 'pistol'; updateGunModel();
            
            [...opponents, ...playerBullets, ...opponentBullets, ...items].forEach(obj => scene.remove(obj.isOpponent ? obj.model : obj));
            opponents = []; playerBullets = []; opponentBullets = []; items = [];
            
            player.position.set(0, playerHeight / 2, 0); camera.rotation.set(0,0,0); player.rotation.set(0,0,0);
            motorcycle.position.set(5, 0, 5); motorcycle.rotation.set(0,0,0); vehicleSpeed = 0;
            
            stormState = "WAITING"; stormTimer = stormWaitTime; stormCurrentRadius = 140; stormTargetRadius = 100;

            spawnOpponents(); spawnItems(); updateUI();

            startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
            document.body.requestPointerLock();
        }

        function endGame(isVictory) {
            gameIsOver = true;
            document.exitPointerLock();
            endTitleElement.textContent = isVictory ? "勝利！" : "遊戲結束";
            endMessageElement.textContent = isVictory ? "您是最後的存活者！" : "您已被擊敗";
            gameOverScreen.style.display = 'flex';
        }

        function handleInteraction() {
            if (playerState === 'DRIVING') {
                playerState = 'WALKING';
                player.position.copy(motorcycle.position).add(new THREE.Vector3(3, 0, 0));
                player.visible = true;
                return;
            }
            if (player.position.distanceTo(motorcycle.position) < 5) {
                playerState = 'DRIVING';
                player.visible = false;
            }
            for (let i = items.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(items[i].position) < 2) {
                    if (items[i].itemType === 'scope') playerHasScope = true;
                    if (items[i].itemType === 'sniper') { playerWeapon = 'sniper'; updateGunModel(); }
                    scene.remove(items[i]); items.splice(i, 1);
                }
            }
        }

        function shoot() {
            if (shootCooldown > 0) return;
            
            recoilAmount = recoilSpeed;
            muzzleFlash.visible = true;
            setTimeout(() => { muzzleFlash.visible = false; }, 60);

            if(playerWeapon === 'sniper') shootCooldown = 1.5;
            else shootCooldown = 0.2;

            const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            const vector = new THREE.Vector3();
            camera.getWorldDirection(vector);

            const muzzleWorldPosition = new THREE.Vector3();
            gun.muzzlePoint.getWorldPosition(muzzleWorldPosition);
            bullet.position.copy(muzzleWorldPosition);
            bullet.velocity = vector.multiplyScalar(playerWeapon === 'sniper' ? 200 : 50);
            
            bullet.damage = playerWeapon === 'sniper' ? 100 : 25;

            scene.add(bullet);
            playerBullets.push(bullet);
        }

        function shootAI(shooter) {
             const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff6666 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            const vector = new THREE.Vector3().subVectors(shooter.target.position, shooter.position).normalize();
           
            bullet.position.copy(shooter.position).add(new THREE.Vector3(0,1.5,0)); // Fire from chest height
            bullet.velocity = vector.multiplyScalar(50);
            bullet.damage = 10;
            bullet.owner = shooter; // 標記子彈發射者
            
            scene.add(bullet);
            opponentBullets.push(bullet);
        }

        function spawnOpponents() {
            for (let i = 0; i < INITIAL_OPPONENTS; i++) {
                const opponentMat = new THREE.MeshPhongMaterial({ color: 0xff8c00 });
                const model = new THREE.Group();
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), opponentMat);
                head.position.y = 1.75;
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.5), opponentMat);
                body.position.y = 1;
                const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), opponentMat);
                armL.position.set(-0.6, 1, 0);
                const armR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), opponentMat);
                armR.position.set(0.6, 1, 0);
                const legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), opponentMat);
                legL.position.set(-0.25, 0, 0);
                const legR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), opponentMat);
                legR.position.set(0.25, 0, 0);
                model.add(head, body, armL, armR, legL, legR);
                model.children.forEach(c => c.castShadow = true);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80 + 40;
                model.position.set(Math.sin(angle) * distance, 0.5, Math.cos(angle) * distance);
                const opponent = {
                    isOpponent: true, model: model, health: 100, state: 'ROAMING', target: null,
                    shootCooldown: Math.random() * 2 + 1,
                    roamTarget: new THREE.Vector3((Math.random() - 0.5) * 200, 1, (Math.random() - 0.5) * 200),
                    get position() { return this.model.position; },
                    lookAt(target) { this.model.lookAt(target); }
                };
                scene.add(model); opponents.push(opponent);
            }
        }
        
        function updatePlayer(delta) {
            const isGrounded = player.position.y <= playerHeight / 2;
            playerVelocity.y += gravity * delta;
            if (controlsEnabled && playerState === 'WALKING') {
                const direction = new THREE.Vector3((keys['KeyA'] ? 1 : 0) - (keys['KeyD'] ? 1 : 0), 0, (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0)).normalize();
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(player.quaternion);
                const moveDirection = new THREE.Vector3().addScaledVector(forward, -direction.z).addScaledVector(right, -direction.x);
                const currentSpeed = isAiming ? playerSpeed * 0.5 : playerSpeed;
                playerVelocity.x = moveDirection.x * currentSpeed;
                playerVelocity.z = moveDirection.z * currentSpeed;
                if (keys['Space'] && isGrounded) playerVelocity.y = jumpHeight;
            } else {
                playerVelocity.x = 0; playerVelocity.z = 0;
            }
            player.position.x += playerVelocity.x * delta;
            player.position.y += playerVelocity.y * delta;
            player.position.z += playerVelocity.z * delta;
            if (player.position.y < playerHeight / 2) {
                player.position.y = playerHeight / 2;
                playerVelocity.y = 0;
            }
        }

        function updateMotorcycle(delta) {
            if(playerState !== 'DRIVING') return;

            const steer = (keys['KeyA'] ? 1 : 0) - (keys['KeyD'] ? 1 : 0);
            if (vehicleSpeed !== 0) motorcycle.rotation.y += steer * motorcycleTurnSpeed * delta;
            if (keys['KeyW']) vehicleSpeed += motorcycleAcceleration * delta;
            else if (keys['KeyS']) vehicleSpeed -= motorcycleBrakePower * delta;
            else vehicleSpeed -= motorcycleFriction * Math.sign(vehicleSpeed) * delta;
            vehicleSpeed = Math.max(-motorcycleMaxSpeed/2, Math.min(motorcycleMaxSpeed, vehicleSpeed));
            if (Math.abs(vehicleSpeed) < 0.1) vehicleSpeed = 0;
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(motorcycle.quaternion);
            motorcycle.position.addScaledVector(forward, -vehicleSpeed * delta);
            motorcycle.wheels.forEach(w => w.rotation.x += (vehicleSpeed/5) * delta);
        }

        function updateCamera() {
            if(playerState === 'DRIVING') {
                const offset = new THREE.Vector3(0, 4, 8);
                offset.applyQuaternion(motorcycle.quaternion);
                const targetPos = motorcycle.position.clone().add(offset);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(motorcycle.position);
            } else {
                camera.position.set(0, playerHeight * 0.8, 0); 
                camera.rotation.x = player.children[0].rotation.x; 
                camera.rotation.y = 0; camera.rotation.z = 0;
            }
        }

        function updateAiming(delta) {
            const aimSpeed = delta * 10;
            let currentAimFov = defaultFov;
            if (isAiming) {
                if (playerWeapon === 'sniper') currentAimFov = 20;
                else if (playerHasScope) currentAimFov = 40;
                else currentAimFov = 60;
            }

            crosshairElement.style.display = controlsEnabled && !isAiming && playerState === 'WALKING' ? 'block' : 'none';
            camera.fov = THREE.MathUtils.lerp(camera.fov, currentAimFov, aimSpeed);
            gun.position.lerp(isAiming ? aimGunPosition : defaultGunPosition, aimSpeed);
            camera.updateProjectionMatrix();
        }
        
        function updateBullets(delta) {
            if (shootCooldown > 0) shootCooldown -= delta;

            const allBullets = [...playerBullets, ...opponentBullets];
            for (let i = allBullets.length - 1; i >= 0; i--) {
                const bullet = allBullets[i];
                bullet.position.add(bullet.velocity.clone().multiplyScalar(delta));
                if (bullet.position.distanceTo(player.position) > 400) {
                    scene.remove(bullet);
                    if (playerBullets.includes(bullet)) playerBullets.splice(playerBullets.indexOf(bullet), 1);
                    else opponentBullets.splice(opponentBullets.indexOf(bullet), 1);
                }
            }
        }
        
        function updateOpponents(delta) {
            for (const opponent of opponents) {
                const distToStormCenter = new THREE.Vector2(opponent.position.x, opponent.position.z).distanceTo(stormCenter);
                
                // --- 目標鎖定 ---
                let closestTarget = null;
                let minDistance = Infinity;
                const potentialTargets = [player, ...opponents];

                for(const target of potentialTargets) {
                    if (!target || (target.isOpponent && opponent === target)) continue; // 跳過自己
                    
                    const dist = opponent.position.distanceTo(target.position);
                    if(dist < minDistance) {
                        minDistance = dist;
                        closestTarget = target;
                    }
                }
                opponent.target = closestTarget;

                // --- 狀態機 ---
                if (distToStormCenter > stormCurrentRadius) {
                    opponent.state = 'FLEEING';
                } else if (minDistance < 60 && opponent.target) {
                    opponent.state = 'ATTACKING';
                } else {
                    opponent.state = 'ROAMING';
                }

                // --- 行動 ---
                let moveDirection = new THREE.Vector3();
                if (opponent.state === 'FLEEING') {
                    moveDirection.set(stormCenter.x - opponent.position.x, 0, stormCenter.y - opponent.position.z).normalize();
                } else if (opponent.state === 'ATTACKING') {
                    const targetPosition = opponent.target.position.clone();
                    targetPosition.y = opponent.position.y;
                    moveDirection.subVectors(targetPosition, opponent.position).normalize();
                    opponent.lookAt(targetPosition);
                    opponent.shootCooldown -= delta;
                    if (opponent.shootCooldown <= 0) { 
                        shootAI(opponent); 
                        opponent.shootCooldown = Math.random() * 2 + 1.5; 
                    }
                } else { // ROAMING
                    if (opponent.position.distanceTo(opponent.roamTarget) < 5) opponent.roamTarget.set((Math.random() - 0.5) * 200, 1, (Math.random() - 0.5) * 200);
                    moveDirection.subVectors(opponent.roamTarget, opponent.position).normalize();
                }
                opponent.position.add(moveDirection.multiplyScalar(7 * delta));
            }
        }
        
        function updateStorm(delta) {
            stormTimer -= delta;
            if (stormTimer <= 0) {
                if (stormState === "WAITING") {
                    stormState = "SHRINKING"; stormTimer = stormShrinkTime;
                } else {
                    stormState = "WAITING"; stormTimer = stormWaitTime;
                    stormTargetRadius *= 0.7; stormShrinkTime *= 0.8; stormWaitTime *= 0.8;
                }
            }
            if (stormState === "SHRINKING") {
                const shrinkRate = (stormCurrentRadius - stormTargetRadius) / stormShrinkTime;
                stormCurrentRadius -= shrinkRate * delta;
            }
            stormMesh.scale.set(stormCurrentRadius, 1, stormCurrentRadius);
        }
        
        function spawnDamageIndicator(position, damage) {
            const indicator = document.createElement('div');
            indicator.className = 'damage-indicator';
            indicator.textContent = `-${damage}`;
            damageContainer.appendChild(indicator);
            const indicatorData = { element: indicator, position: position.clone().add(new THREE.Vector3(0, 2, 0)), life: 1.0 };
            damageIndicators.push(indicatorData);
        }

        function updateDamageIndicators(delta) {
            for (let i = damageIndicators.length - 1; i >= 0; i--) {
                const data = damageIndicators[i];
                data.life -= delta;
                if (data.life <= 0) { damageContainer.removeChild(data.element); damageIndicators.splice(i, 1); continue; }
                data.position.y += 1 * delta;
                const screenPos = data.position.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                data.element.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                data.element.style.opacity = data.life;
            }
        }

        function checkCollisions() {
            // 玩家子彈 vs 對手
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                for (let j = opponents.length - 1; j >= 0; j--) {
                    if (playerBullets[i] && opponents[j] && playerBullets[i].position.distanceTo(opponents[j].position) < 1.8) {
                        const damage = playerBullets[i].damage;
                        opponents[j].health -= damage;
                        spawnDamageIndicator(opponents[j].position, damage);
                        scene.remove(playerBullets[i]);
                        playerBullets.splice(i, 1);
                        if (opponents[j].health <= 0) {
                            scene.remove(opponents[j].model);
                            opponents.splice(j, 1);
                            opponentsLeft--;
                            if (opponentsLeft === 0) endGame(true);
                        }
                        break;
                    }
                }
            }
            
            // 對手子彈 vs 任何人
            for (let i = opponentBullets.length - 1; i >= 0; i--) {
                const bullet = opponentBullets[i];
                if (!bullet) continue;

                // 檢查是否擊中玩家
                if (bullet.position.distanceTo(player.position) < 1.5) {
                    health -= bullet.damage;
                    updateUI();
                    if (health <= 0) { health = 0; endGame(false); }
                    scene.remove(bullet);
                    opponentBullets.splice(i, 1);
                    continue; // 子彈已處理
                }

                // 檢查是否擊中其他對手
                for (let j = opponents.length - 1; j >= 0; j--) {
                    const opponent = opponents[j];
                    if (bullet.owner === opponent) continue; // 不能射自己

                    if (bullet.position.distanceTo(opponent.position) < 1.8) {
                        const damage = bullet.damage;
                        opponent.health -= damage;
                        spawnDamageIndicator(opponent.position, damage);
                        scene.remove(bullet);
                        opponentBullets.splice(i, 1);
                        if (opponent.health <= 0) {
                            scene.remove(opponent.model);
                            opponents.splice(j, 1);
                            opponentsLeft--;
                        }
                        break; 
                    }
                }
            }

            // 載具 vs 對手
            if (playerState === 'DRIVING' && Math.abs(vehicleSpeed) > 10) {
                 for (let j = opponents.length - 1; j >= 0; j--) {
                    if (opponents[j] && motorcycle.position.distanceTo(opponents[j].position) < 2.5) {
                        const damage = 100;
                        opponents[j].health -= damage; 
                        spawnDamageIndicator(opponents[j].position, damage);
                         if (opponents[j].health <= 0) {
                            scene.remove(opponents[j].model);
                            opponents.splice(j, 1);
                            opponentsLeft--;
                            if (opponentsLeft === 0) endGame(true);
                        }
                    }
                }
            }
        }

        function checkStormDamage() {
            const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
            if (playerPos2D.distanceTo(stormCenter) > stormCurrentRadius) {
                health -= STORM_DAMAGE;
                updateUI();
                stormWarningElement.style.display = 'block';
                if (health <= 0) { health = 0; endGame(false); }
            } else {
                stormWarningElement.style.display = 'none';
            }
        }

        function checkInteractions() {
            interactionPrompt.style.display = 'none';
            if (playerState === 'WALKING') {
                 if (player.position.distanceTo(motorcycle.position) < 5) {
                    interactionPrompt.textContent = "按 E 鍵騎車";
                    interactionPrompt.style.display = 'block';
                }
                for (const item of items) {
                     if (player.position.distanceTo(item.position) < 2) {
                        if (item.itemType === 'scope') interactionPrompt.textContent = "按 E 鍵撿起瞄準鏡";
                        else if (item.itemType === 'sniper') interactionPrompt.textContent = "按 E 鍵撿起狙擊槍";
                        interactionPrompt.style.display = 'block';
                    }
                }
            }
        }

        function updateUI() {
            opponentsLeftElement.textContent = `對手: ${opponentsLeft}`;
            healthElement.textContent = `生命值: ${Math.ceil(health)}`;
            stormTimerElement.textContent = `風暴 ${stormState === 'WAITING' ? '來襲' : '縮小'}: ${Math.ceil(stormTimer)}s`;
            
            const healthPercent = Math.max(0, health) / 100;
            healthBar.style.width = `${healthPercent * 100}%`;
            if (healthPercent > 0.6) {
                healthBar.style.backgroundColor = '#4caf50'; // Green
            } else if (healthPercent > 0.3) {
                healthBar.style.backgroundColor = '#ffc107'; // Yellow
            } else {
                healthBar.style.backgroundColor = '#f44336'; // Red
            }

            let statusText = '';
            if (playerWeapon === 'sniper') statusText = '已裝備狙擊槍';
            else if (playerHasScope) statusText = '已裝備瞄準鏡';
            
            if (statusText) {
                itemStatusElement.textContent = statusText;
                itemStatusElement.style.display = 'block';
            } else {
                itemStatusElement.style.display = 'none';
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (!gameIsOver) {
                const delta = clock.getDelta();
                updatePlayer(delta);
                updateMotorcycle(delta);
                updateCamera();
                updateBullets(delta);
                updateOpponents(delta);
                if(playerState === 'WALKING') updateAiming(delta);
                updateStorm(delta);
                updateDamageIndicators(delta);
                checkCollisions();
                checkStormDamage();
                checkInteractions();
                updateUI();
            }
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>

